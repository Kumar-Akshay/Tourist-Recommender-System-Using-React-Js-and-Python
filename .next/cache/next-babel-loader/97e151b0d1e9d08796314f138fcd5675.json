{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport connectDb from \"../../utils/connectDb\";\nimport Userauth from \"../../models/Userauth\";\nimport bcrypt from \"bcrypt\";\nimport jwt from \"jsonwebtoken\"; //connectDb();\n\nconsole.log(\"Heyyy\");\nexport default /*#__PURE__*/(function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req, res) {\n    var _req$body, email, password, user, passwordsMatch, token;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            console.log(\"Heyyy  2 \");\n            _req$body = req.body, email = _req$body.email, password = _req$body.password;\n            console.log(email);\n            console.log(password);\n            _context.prev = 4;\n            _context.next = 7;\n            return Userauth.findOne({\n              email: email\n            }).select(\"+password\");\n\n          case 7:\n            user = _context.sent;\n\n            if (user) {\n              _context.next = 10;\n              break;\n            }\n\n            return _context.abrupt(\"return\", res.status(404).send(\"No user exists with that email\"));\n\n          case 10:\n            _context.next = 12;\n            return bcrypt.compare(password, user.password);\n\n          case 12:\n            passwordsMatch = _context.sent;\n\n            // 4) --if so, generate a token\n            if (passwordsMatch) {\n              token = jwt.sign({\n                userId: user._id\n              }, process.env.JWT_SECRET, {\n                expiresIn: \"1d\"\n              }); // 5) send that token to the client\n\n              res.status(200).json(token);\n            } else {\n              res.status(401).send(\"Passwords do not match\");\n            }\n\n            _context.next = 20;\n            break;\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](4);\n            console.error(_context.t0);\n            res.status(500).send(\"Error logging in user\");\n\n          case 20:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 16]]);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n})();","map":{"version":3,"sources":["C:/Users/Samee/Desktop/Portfolio/react-reserve-master/pages/api/login.js"],"names":["connectDb","Userauth","bcrypt","jwt","console","log","req","res","body","email","password","findOne","select","user","status","send","compare","passwordsMatch","token","sign","userId","_id","process","env","JWT_SECRET","expiresIn","json","error"],"mappings":";;AAAA,OAAOA,SAAP,MAAsB,uBAAtB;AACA,OAAOC,QAAP,MAAqB,uBAArB;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,OAAOC,GAAP,MAAgB,cAAhB,C,CAEA;;AACAC,OAAO,CAACC,GAAR,CAAY,OAAZ;AAEA;AAAA,sEAAe,iBAAOC,GAAP,EAAYC,GAAZ;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEbH,YAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AAFa,wBAIeC,GAAG,CAACE,IAJnB,EAILC,KAJK,aAILA,KAJK,EAIEC,QAJF,aAIEA,QAJF;AAKbN,YAAAA,OAAO,CAACC,GAAR,CAAYI,KAAZ;AACAL,YAAAA,OAAO,CAACC,GAAR,CAAYK,QAAZ;AANa;AAAA;AAAA,mBASQT,QAAQ,CAACU,OAAT,CAAiB;AAAEF,cAAAA,KAAK,EAALA;AAAF,aAAjB,EAA4BG,MAA5B,CAAmC,WAAnC,CATR;;AAAA;AASLC,YAAAA,IATK;;AAAA,gBAWNA,IAXM;AAAA;AAAA;AAAA;;AAAA,6CAYFN,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,gCAArB,CAZE;;AAAA;AAAA;AAAA,mBAekBb,MAAM,CAACc,OAAP,CAAeN,QAAf,EAAyBG,IAAI,CAACH,QAA9B,CAflB;;AAAA;AAeLO,YAAAA,cAfK;;AAgBX;AACA,gBAAIA,cAAJ,EAAoB;AACZC,cAAAA,KADY,GACJf,GAAG,CAACgB,IAAJ,CAAS;AAAEC,gBAAAA,MAAM,EAAEP,IAAI,CAACQ;AAAf,eAAT,EAA+BC,OAAO,CAACC,GAAR,CAAYC,UAA3C,EAAuD;AACnEC,gBAAAA,SAAS,EAAE;AADwD,eAAvD,CADI,EAIlB;;AACAlB,cAAAA,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBY,IAAhB,CAAqBR,KAArB;AACD,aAND,MAMO;AACLX,cAAAA,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,wBAArB;AACD;;AAzBU;AAAA;;AAAA;AAAA;AAAA;AA2BXX,YAAAA,OAAO,CAACuB,KAAR;AACApB,YAAAA,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB,uBAArB;;AA5BW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAf;;AAAA;AAAA;AAAA;AAAA","sourcesContent":["import connectDb from \"../../utils/connectDb\";\r\nimport Userauth from \"../../models/Userauth\";\r\nimport bcrypt from \"bcrypt\";\r\nimport jwt from \"jsonwebtoken\";\r\n\r\n//connectDb();\r\nconsole.log(\"Heyyy\");\r\n\r\nexport default async (req, res) => {\r\n\r\n  console.log(\"Heyyy  2 \");\r\n\r\n  const { email, password } = req.body;\r\n  console.log(email);\r\n  console.log(password);\r\n  try {\r\n    // 1) check to see if a user exists with the provided email\r\n    const user = await Userauth.findOne({ email }).select(\"+password\");\r\n    // 2) --if not, return error\r\n    if (!user) {\r\n      return res.status(404).send(\"No user exists with that email\");\r\n    }\r\n    // 3) check to see if users' password matches the one in db\r\n    const passwordsMatch = await bcrypt.compare(password, user.password);\r\n    // 4) --if so, generate a token\r\n    if (passwordsMatch) {\r\n      const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, {\r\n        expiresIn: \"1d\"\r\n      });\r\n      // 5) send that token to the client\r\n      res.status(200).json(token);\r\n    } else {\r\n      res.status(401).send(\"Passwords do not match\");\r\n    }\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).send(\"Error logging in user\");\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}